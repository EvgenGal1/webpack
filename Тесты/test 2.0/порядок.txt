1.Урок........................................................................................

1.0 $$ node -v и $$ npm -v - Проверить есть ли на компьютере node.js и npm. Yarn альтернатива NPM(от Травника)
	$$ - вызов команды в терминале
  // - комментарий(напротив)
  ## - код(между)(можно копир сразу)
  ++ - содать/прописать(файл, папку) или автомат добавит
  !! - ссылки к истчнику
1.1 $$ npm init (npm init -y) - инициализация. ++ настр. в команд строке + 1 файл
  ++ настр. в ком.стр.
    // имя приложения/пакета (от назв. папки)
    name: webpack  
    version: 1.0.0
    // краткое описание приложения
    description: My zaeb  
    // точка входа в приложение
    main: index.js  
    test command:
    git repository:
    keywords: 
    author: EvGen Gal
    license: (ISC)
	+++ создаёться файл package.json - описание проекта(конфиг,пакет,отдельная прога) и все установленные зависимости(др. пакеты) с именами и версиями
1.2 $$ npm install webpack ($$ npm i -D webpack webpack-cli webpack-dev-server) - сборка проекта ++ 2 файла
  объясн. команд {
    // npm run - начало команды
    // ctrl + с - остановка процесса (watch/server)
    // dependencies — npm-пакеты, `зависимости` приложения для production
    // devDependencies — npm-пакеты, для разработке проекта, но не при его реальной работе
    // webpack - модульный сборщик (упаковка, компиликтовка и организация ресурсов для проекта)
    // webpack-cli - инструмент для запуска webpack из командной строки
    // webpack-dev-server - локальный `сервер разработки веб-пакет` с живой перезагрузкой
    // -S --save - вкл пакет в раздел dependencies. упразднён с webpack 5
    // -D, --save-dev: вкл пакет в раздел devDependencies
  }
	+++ создаётся папка node_modules - пакеты, установленные вручную, и их зависимости.
  +++ создаётся файл package-lock.json
1.3 ++ настр. файла пакетных зависимостей package.json
  // ^ - значок автоматически обновляет версию. Могут быть конфликты из-за разных версий webpack, webpack-cli и webpack-dev-server. В прошлый раз помог Травник - переустановили их без ^. Перед этим полностью удалили node_modules
  // dependencies — npm-пакеты, `зависимости` приложения для production
  // devDependencies — npm-пакеты, для разработке проекта, но не при его реальной работе
  // npm run - начало команды
  // ctrl + с - остановка процесса (watch/server)
  "scripts"{
    // "...": "./node_modules/.bin/webpack" или "webpack" - под сокращ именем ... , запуск. бинарный файл в опред. дериктории(webpack)
    // cross-env пакет опред какая система(windows, ) и корректно задаёт системную переменную(разраб/прод). // $$ npm i -D cross-env
    // NODE_ENV=development систем. перем. делаем разраб. 
    // ??? не раб с webpack-dev-server
    // NODE_ENV=production систем. перем. делаем произв.
    // режим разработки ($$ npm run dev)
    "dev": "cross-env NODE_ENV=development webpack --mode development",
    // реконвертация кода (обновление изменений не выходя из процесса, следит за изменением файлов)
    "watch": "cross-env NODE_ENV=development webpack --mode development -watch",
    // локал сервер, в разраб, с открытием страницы
    "start": "webpack server --mode development --open",
    // режим производства, мини сборка
    "build": "cross-env NODE_ENV=production webpack --mode production",
    // webpack-dev-server так же как webpack собирает файлы из вывода, но складывает в опер память. поэтому при server нет доступа к выводной папке, для быстрого обновл
    // analyzer выводим в отдельный файл. analyzer - визуал размер выходных файлов веб-пакета в локал сервер
    // "stats": "webpack --json > stats.json && webpack-bundle-analyzer stats.json"
  }
  // основной файл это index.js. е/и не хотим случайно публиковать, пишем private
  "main": "index.js"(webpack.config.js),
  // приватный не публикуемый проект
  "private":"true",
  // оптимизировать для браузеров которые не мертвы и >25%
  // ??? не раб с dev-server
  // "browserslist": "> 0.25%, not dead",
  !!! https://habr.com/ru/company/ruvds/blog/423703/ настройки package.json и package-lock.json
1.4 ++ основные команды ++ доп. библиотеки
  // команды
    // копир и вызов по порядку, без `$$`
    // часто используемые
      // инициализация
      $$ npm init
      // установка(+сервер)
      $$ npm i -D webpack webpack-cli webpack-dev-server
      // html, css(+sass) css в 1, файл, очистка, копир., бабел(+env,react), eslint(ошб+чтен), 
      $$ npm i -D html-webpack-plugin style-loader css-loader sass-loader node-sass sass mini-css-extract-plugin file-loader clean-webpack-plugin copy-webpack-plugin babel-loader @babel/core @babel/preset-env @babel/preset-react eslint eslint-loader babel-eslint
      
      // jQ, React, кросбраузерн css
      $$ npm i -S jquery react react-dom normalize.css 

      // доп. fn() js, babel ошб. console
      $$ npm i lodash @babel/polyfill 
      // plg lodash(чтен. lodash), analyzer(визуал код), cross-env(сист.перем.), babel ошб. console
      $$ npm i -D babel-plugin-lodash webpack-bundle-analyzer cross-env @babel/plugin-proposal-class-properties
    // редко + не понятно
      // ts, less, xml, csv(+зависим)
      $$ npm i -D @babel/preset-typescript less-loader xml-loader csv-loader papaparse

      $$ npm install @babel/plugin-proposal-class-propertiesnpm install @babel/plugin-proposal-class-properties // babel, для обработки синтаксиса, пока не доступтного JS
      $$ npm install prop-types // Для контроля типов передаваемых в компонент propsов можно использовать стороннюю библиотеку PropTypes.
      $$ npm install material-ui // библиотека от Google, которая позволяет создавать приложения в стиле Google Material Design с использованием компонентов React.
  // библ, настр, стили
    // jQuery - библ. JS > html
      // устан. пакета на Prod
      $$ npm i -S jquery
      // подкл в .js файл
      ## import * as $ from "jquery";
      ## import $ from "jquery";
    // normalize - единые стили для кросбраузерн
      // устан. пакета на Prod
      $$ npm i normalize.css 
      // подкл в .css первым. указ. ~ переход в node_module
      ## @import '~normalize.css';
      // или подкл. в .html до css
      ## <link rel="stylesheet" type="text/css" href="css/normalize.css" />
    // cross-env - опред. системы(windows, ) и задаёт систем. перемен.(разраб/прод). 
      // устан. в Dev
      // $$ npm i -D cross-env
      // NODE_ENV=development систем. перем. делаем разраб. ??? не раб с webpack-dev-server
      // NODE_ENV=production систем. перем. делаем произв.
      // прописать в package.json 
      ## "dev": "cross-env NODE_ENV=development webpack --mode development",
      ## "build": "cross-env NODE_ENV=production webpack --mode production",
    // lodash - биб JS, чтоб писать компакт. и простой в обслуживании JS код.
      !! https://lodash.com/
      // устан. пакета на Prod
      $$ npm i lodash
      // устан. обаботчика пакета на Dev
      $$ npm i -D babel-plugin-lodash
      // подкл. в любой .js файл. использ. при динамическом import. 
      ## import _ from "lodash";
      ## import { add } from "lodash/fp";
      // пример. 
      ##
      var array = [1];
      var other = _.concat(array, 2, [3], [[4]]);
      console.log(other); // => [1, 2, 3, [4]]
      console.log(array); // => [1]
      console.log("Lodash", _.random(0, 43, true));  // => Lodash от 0 до 43
      ##
    // analyzer - визуал размер выходных файлов веб-пакета в локал сервер
      !! https://www.npmjs.com/package/webpack-bundle-analyzer
      $$ npm i -D webpack-bundle-analyzer  
      // подк. плагин в webpack.config.js
      ## const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer')
      // пропис fn() с plugins и analyzer(Prod)
      ##
      const plugins = () => {
        const base = [
          new HTMLWebpackPlugin({.....})
          new CleanWebpackPlugin({.....})
        ]
        // подк. е/и Prod
        if (isProd) {
          base.push(new BundleAnalyzerPlugin());
        }
        return base;
      };
      ##
      // вызов fn() в plugin. закомитев [] в plugins:
      ## plugins: plugins(), // [ ..... ]
1.5 ++ Создать в корне проекта webpack.config.js - настройка webpack
  мини база
    ##
      const path = require("path");

      module.exports = {
        mode: "development",
        entry: {
          main: path.resolve(__dirname, "src", "index.jsx")
        }, 
        output: {
          path: path.resolve(__dirname, "static", "build"),
          filename: "app.js",
        },
      };
    ##
  стандарт база
    ##
      const path = require("path");

      module.exports = {
        mode: "development",
        entry: {
          main: path.resolve(__dirname, "src", "index.jsx")
        }, 
        output: {
          path: path.resolve(__dirname, "static", "build"),
          filename: "app.js",
        },
      };
    ##
  описание базы + команды
    ##
      // подключение пакет пафз через константу. для корректного поиска точки входа
      const path = require("path"); // `путь`=`требует`
      // html выгр, подкл css, js
      const HTMLWebpackPlugin = require("html-webpack-plugin");
      // очистка выводной папки
      const { CleanWebpackPlugin } = require("clean-webpack-plugin");
      // копир файлов из корня в вывод
      const CopyWebpackPlugin = require("copy-webpack-plugin");
      // css + mini... css в отдельные файлы + loader
      const MiniCssExtractPlugin = require('mini-css-extract-plugin');
      // cssmini вывод - по документации
      // ??? не раб - прибавляет очень много веса
      // const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
      // cssmini вывод - по видео
      const OptimizeCssAssetWebpackPlugin = require('optimize-css-assets-webpack-plugin')
      const TerserWebpackPlugin = require('terser-webpack-plugin')
      // analyzer подк. визуал размер кода
      const {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer')

      // пути в константу(QF3EcxymIcc)(для удобной смены во всем сразу)
      // PATHS.src(dist) - ярлык. './src/'(./dist/) - изменяемая переменая
      const PATHS = {
        src: path.join(__dirname, "./src/"),
        dist: path.join(__dirname, "./dist/"),
        static: "static/",
      };

      // режимы разраб/продукт ч/з систем перем.
      // $$ npm i -D cross-env - корректно задаёт системную переменную(разраб/прод). прописать в packege.json
      const isDev = process.env.NODE_ENV === 'development'
      const isProd = !isDev

      // перименовка файлов в зависимости от режима. более сложное для Prod для кэша
      // const filename = (ext) => (isDev ? `[name].${ext}` : `[name].[hash].${ext}`);
      // дополнил. при передаче ext, созд. идентич. папку и формат. ЛУЧШЕЕ для css, js
      isDev ? `${ext}/[name].${ext}` : `${ext}/[name].[hash].${ext}`;

      // fn для передачи объ. в optimization с проверкой на Prod
      const optimization = () => {
        // объ. конфиг по умолчанию
        const config = {
          splitChunks: {
            // объедин/разъедин доп библ js (jQ, React). в один файл из 2х не связаных файлов
            chunks: "all", // async
          },
        };
        // е/и prod(true) в minimize добавл. cssmini а css объединяет в один файл
        if (isProd) {
          (config.minimizer = [
            // с видео
            // cssmini вывод
            new OptimizeCssAssetWebpackPlugin(),
            new TerserWebpackPlugin(),
            // с webpack документации
            // ??? не раб - прибавляет очень много веса, хоть и mini
            // new CssMinimizerPlugin(),
          ]),
          // CSS в один файл
          (config.splitChunks = {
            // объедин/разъедин доп библ js (jQ, React)
            chunks: "all", // async
            cacheGroups: {
              styles: {
                // путь/имя
                name: "styles",
                // убирает доп файл , хз что за js
                type: "css/mini-extract",
                // For webpack@4
                // test: /\.css$/,
                chunks: "all",
                enforce: true,
              },
            },
          });
        }
        // возращ по умолчан
        return config;
      };

      // убираем дубли loader в css, scss, less
      const cssLoaders = (extra) => {
        // массив по умолчанию
        const loaders = [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              // hmr: isDev,
              // reloadAll: true,
            },
          },
          // MiniCssExtractPlugin.loader,
          "css-loader",
        ];
        // если есть передаваемый параметр(extra) добовл. его в конце массива
        if (extra) {
          loaders.push(extra);
        }
        // возвращ умолч
        return loaders;
      };

      // убираем дубли babel options в JS, JSX, TS
      const babelOptions = preset => {
        const opts = {
          presets: [
            '@babel/preset-env'
          ],
          plugins: [
            '@babel/plugin-proposal-class-properties'
          ]
        }
        if (preset) {
          opts.presets.push(preset)
        }
        return opts
      }

      // eslint(анализ проблем в js коде) счас только для rules:js
      const jsLoaders = () => {
        // по умолчанию. возращ массив
        // const loader = [
        const user = [
          {
            loader: "babel-loader",
            options: babelOptions(),
          },
        ];
        // е/и раработка, то добавл eslint
        if (isDev) {
          user.push("eslint-loader");
        }
        // возвращ
        return user;
      };

      // analyzer(визуал размер кода) и plugin ч/з fn()
        // описание plugin в plugins:стандарт + описание
        const plugins = () => {
          const base = [
            new HTMLWebpackPlugin({
              minify: {
                collapseWhitespace: isProd,
              },
              chunks: ["main"],
              filename: `${PATHS.dist}index.html`,
              template: `${PATHS.src}index.html`,
            }),
            new HTMLWebpackPlugin({
              minify: {
                collapseWhitespace: isProd,
              },
              chunks: ["app"],
              filename: `${PATHS.dist}html/indexReact.html`,
              template: `${PATHS.src}html/indexReact.html`,
            }),
            new MiniCssExtractPlugin({
              filename: filename("css"),
            }),
            new CleanWebpackPlugin(),
            new CopyWebpackPlugin({
              patterns: [
                {
                  from: path.resolve(__dirname, "./src/favicon.ico"),
                  to: path.resolve(__dirname, "dist"),
                },
                {
                  from: `${PATHS.src}fonts`,
                  to: `${PATHS.dist}fonts`,
                },
              ],
            }),
          ];
          // analyzer подк. е/и Prod
          if (isProd) {
            base.push(new BundleAnalyzerPlugin());
          }
          return base;
        };

      // экспорт настроек плагинов объ., из док.(config) 
      module.exports = {
        // укажем где исходники. путает в fn(), PATHS, наборе имени
        // context: path.resolve(__dirname, "src"),
        // `режим разработки`
        mode: "development", 
        // точка входа, начало сборки
        entry: { 
          // сборка из .src/
          // main`главный(ярлык)`: модуль path`путь` resolve`разрешает` dirname`корневая папк`
          // главный/имя/путь/ярлык - влияет на имя файлов при [name]
          // path.resolve - составл. статический путь из указаных пунктов в скобках
          // делаеться потому что путь в некоторых системах выглядит по другому
          // в существуюших папках ищет нужное
          // можно указ. входной файл .jsx, чтоб node не искал только js по умолчанию
          // одна точка входа.
            // имя при выходе(ярлык) main: ... путь(корн.папка, src/index.js)
            // main: path.resolve(__dirname, "src", "index.js")
          // точка входа + путь в ярлыке
            // имя/путь(на выходе запишется в js/main.js)
            // "js/main": "./src/js/index.js"
          // неско-ко точек входа.
            // имя на выходе: путь до входного файла
            // main: "./src/js/index.js",
            // в [] пердаем доп. библ.(polyfil, lodash, )
            // appic: ["@babel/polyfill","./src/js/indexReact.jsx"],
          // неско-ко точек входа + PATHS. ЛУЧШЕЕ!!!
            // ярлык main: найти в корн.папки/src. js найдёт сам
            main: PATHS.src,
            // найдёт в src/js/indexReact.jsx. синтаксис ES6
            app: `${PATHS.src}js/indexReact.jsx`,
        },
        // точка вывода
        output: { 
          // стандарт
            // выгруж. в ./static/build/app.js
            // path: path.resolve(__dirname, "static", "build"),
            // filename: "app.js",
            // [name] добав уникальность(патерн). их много
          fn() + PATHS. ЛУЧШЕЕ!!!
            // с fn() создаст js/[name].js
            filename: filename("js"),
            // склад в static/js/[name].js синтакс ES6
            // filename: `${PATHS.static}js/[name].js`,
            // созд. в корн.папке/dist
            path: PATHS.dist,
        },
        // доп. узкие настр.
        plugins:
          // стандарт + описание
            // [ 
            //   // html плагин {
            //     // html выгрузка и авто подкл css, js
            //     // $$ npm i -D html-webpack-plugin
            //     new HTMLWebpackPlugin({
            //       // стандарт
            //        // загрузка из src
            //        // template: "./src/index.html",
            //        // выгрузка по умолч. в корн.папку(dist)
            //       // с PATHS. ЛУЧШЕЕ!!!
            //         // выгрузка - dist/index.html
            //         filename: `${PATHS.dist}index.html`,
            //         // загрузка - src/index.html
            //         template: `${PATHS.src}index.html`,
            //       // добавл. `куски` кода js, css из entry
            //       chunks: ['main'],
            //       // мини выгрузка в режиме Prod
            //       minify: {
            //         collapseWhitespace: isProd,
            //       },
            //     }),
            //     // второй файл html
            //     new HTMLWebpackPlugin({
            //       // стандарт
            //        // загрузка из src/html/
            //        // template: "./src/html/indexReact.html",
            //        // выгрузка /html/NoReact/
            //        // filename: "./html/React/indexReact.html",
            //       // с PATHS. ЛУЧШЕЕ!!!
            //         // выгрузка - dist/html/indexReact.html
            //         filename: `${PATHS.dist}html/indexReact.html`,
            //         // загрузка - src/html/indexReact.html
            //         template: `${PATHS.src}html/indexReact.html`,
            //       // добавл. `куски` кода js, css из entry
            //       chunks: ['app', 'analytics'],
            //       // мини выгрузка в режиме Prod
            //       minify: {
            //         collapseWhitespace: isProd,
            //       },
            //     }),
            //   // }
            //   // css + mini {
            //     // css в отдельные файлы
            //     // $$ npm i -D mini-css-extract-plugin
            //     new MiniCssExtractPlugin({
            //       // [name] присвоит имя из entry, можно прописать имя
            //       // filename: '[name].css',
            //       // с fn() создаст css/[name].css ЛУЧШЕЕ!!
            //       filename: filename("css"),
            //       // для произв. раздел. на отдел. `куски`(асинхр. загр., )
            //       // chunkFilename: '[id].css',
            //     }),
            //   // }
            //   // очистка выводной папки {
            //     // $$ npm i -D clean-webpack-plugin
            //     new CleanWebpackPlugin(),
            //   // }
            //   // копир файлов {
            //     // копир файлов(папок) из корня(src) в вывод
            //     // $$ npm i -D copy-webpack-plugin
            //     new CopyWebpackPlugin({
            //       patterns: [
            //         {
            //           // от куда и куда копир(файлы, папки)
            //           // стандарт
            //             // from: path.resolve(__dirname, "src/favicon.ico"),
            //             // to: path.resolve(__dirname, "dist"),
            //           // копир с PATHS
            //             // всё из src/img в dist/img
            //             // откл чтоб задать через module.rules
            //             // {
            //             //   from: `${PATHS.src}img`,
            //             //   to: `${PATHS.dist}img`,
            //             // },
            //             {
            //               from: `${PATHS.src}fonts`,
            //               to: `${PATHS.dist}fonts`,
            //             },
            //         },
            //       ],
            //     }),
            //   // }
            // ],
          // analyzer для Prod ч/з fn()plugins
            // визуал размер выходных файлов веб-пакета в локал сервер Prod
            // $$ npm i -D webpack-bundle-analyzer  
            plugins()
          // ! е/и не нужен analyzer - раскомит `стандарт + описание` всё с [] один раз и закомит вызов fn()`plugins()` в analyzer для Prod
        // конфигурация модулей(загрузчиков)
        module: { 
          // `правила` для модулей (настройка, параметры парсера и т. д.)
          rules: [
            // пояснения {
              // загрузчики для предварительной обработки файлов
              // test - какое расширение.
              // exclude - исключения.
              // указ. webpack какой loader использовать
            // }
            // BABEL(JS,JSX,TS) - компилирует код { 
              // превращ. ECMAScript.next код в ECMAScript 5 (конструкторы). заменяет весь новый код на старый
              // устан. babel 
              // $$ npm install -D babel-loader @babel/core @babel/preset-env 
              // устан. полифил от ошибки "Uncaught ReferenceError: regeneratorRuntime is not defined" в браузере
              // $$ npm i -S @babel/polyfill
              // подкл. в entry: вместе с index.js как отдельн. библ.
              // entry:{main: ["@babel/polyfill","./index.js"]}
              // устан плагин чтоб не было ошибок в консоли
              // $$ npm i -D @babel/plugin-proposal-class-properties
              // подкл. в plugins: []
              // подроб. {
                // babel-loader - адаптер м/у webpaсk и babel
                // core - ядро/ ? переводчик
                // preset - доп. настр.(набор плагинов для js) как компил. версии js
                // polyfill - 
                // proposal-class-properties - плагин для удобства?
              // }
              // JS 
                {
                  // для js. синтаксис регулярных выражений
                  test: /\.js?$/,
                  // исключ. папка node_modules
                  exclude: /(node_modules)/,
                  // указ. webpack какой loader использовать
                  // станд + option + с fn()/без
                    // use: {
                      // загрузчик - babel (собирает js файлы)
                      // loader: "babel-loader",
                      // в опциях доп. настр.
                      // options:
                        // без fn()
                            // указываем плагины babel. их можно указать в файле .babelrc только в формате json, прописано там же
                            // presets: ["@babel/preset-env"],
                            // plugins: ["@babel/plugin-proposal-class-properties"], // , { loose: true }
                        // с fn() babelOptions без дублей. ЛУЧШЕЕ!!!
                          // babelOptions()
                    }
                  // eslint. ЛУЧШЕЕ!!!
                    // анализ проблем в js коде
                    // Инструмент статического анализа кода для выявления проблемных паттернов, обнаруженных в коде JavaScript.
                    // мождно добавл желаемым. файлам js
                    // ошибки в коде при сборке выдают предупр/ошибку. ? в файлах подсвечиватся
                    // устан. пакет, loader и babel
                    // $$ npm i -D eslint eslint-loader babel-eslint
                    // ++ созд. и настр. файл .eslintrc
                    // настройку файлы вырез/копир и раскомитеть м/у ##
                      // ## 
                        // {
                        //   // явно указыв с чем работаем(babel-eslint)
                        //   "parser": "babel-eslint",
                        //   // правила
                        //   "rules": {
                        //     // вкл прав. как предупрежд., чтоб проек собирался. error - не даст собратся
                        //     "no-unused-vars": "warn"
                        //   },
                        //   // указ где работаем
                        //   "env": {
                        //     // чтоб понимал промисы
                        //     "es6": true,
                        //     // чтоб понимал консоли
                        //     "browser": true
                        //   },
                        //   // расширение
                        //   "extends": [
                        //     // наследуемся: рекондуется
                        //     "eslint:recommended"
                        //   ]
                        // }
                      // ##
                    // пример только для js
                      // loader для объ.? use для массивов? через fn()
                      use: jsLoaders(),
                }
              // JSX 
                {
                  // устан react и react-dom
                  // $$ npm install react react-dom
                  // подкл в файл .JSX
                  // ## import React from 'react'
                  // ## import { render } from 'react-dom'
                  // babel react устан и настр
                  // $$ npm i -D @babel/preset-react
                  // ~## entry: {main3:"./fail3.jsx"}
                  // для js и/или jsx. синтаксис регулярных выражений
                  test: /\.jsx?$/i, // есть такой test: /\.(js|jsx)$/,
                  // исключ. папка node_modules
                  exclude: /(node_modules)/,
                  // указ. webpack какой loader использовать
                  use: {
                    // загрузчик - babel (собирает jsx файлы)
                    loader: "babel-loader",
                    // в опциях доп. настр.
                    options: 
                    // без fn()
                        // указываем плагины babel. их можно указать в файле .babelrc только в формате json, прописано там же
                        // presets: ["@babel/preset-env", "@babel/preset-react"],
                        // plugins: ["@babel/plugin-proposal-class-properties"], // , { loose: true }
                    // с fn() babelOptions без дублей. ЛУЧШЕЕ!!!
                      babelOptions("@babel/preset-react")
                  },
                }
              // TS      
                // typescript babel устан и настр
                // $$ npm i -D @babel/preset-typescript
                // entry: {main3:"./fail3.ts"}
                {
                  test: /\.ts$/,
                  exclude: /node_modules/,
                  use: {
                    loader: "babel-loader",
                    options: 
                    // без fn()
                      // {
                        // presets: ["@babel/preset-env" , "@babel/preset-typescript"],
                        // plugins: ["@babel/plugin-proposal-class-properties"],//, { loose: true }
                      // },
                    // с fn() babelOptions без дублей
                      babelOptions("@babel/preset-typescript"),
                  },
                },
            // },
            // CSS (стили|4 варианта) {
              // обраб. ccs файлы с импортами и возвращает ccs код.
              // $$ npm i -D css-loader
              // CSS + style{
                // Грузить стили в head, не файл
                // $$ npm i -D style-loader
                // Подкл. CSS в JS файлах к странице(html), перед этим превратив их в строку. 
                // +++ import './test1.css'; // подкл. .css в src/.js
                {
                  test: /\.css$/i,
                  use: ["style-loader", "css-loader"],
                },
              // },
              // CSS + mini{
                // для отдельных css файлов
                // $$ npm i --D mini-css-extract-plugin
                // +++ const MiniCssExtractPlugin
                // +++ plugins:[new MiniCssExtractPlugin()]
                // подкл. .css в src/.js
                // +++ import './test2.css'; 
                // подкл. css в html. не нежен с html плагин
                // +++ <link rel="stylesheet" href="./static/build/styles.css">  
                {
                  test: /\.css$/i,
                  // с fn() cssLoaders без дублей. ЛУЧШЕЕ!!!
                    use: cssLoaders(),
                  // стандарт
                    // use: [
                      // без опций
                        // MiniCssExtractPlugin.loader, 'css-loader'
                      // опции + доп.
                        // {
                          // прямо указ какой loader
                          // loader: MiniCssExtractPlugin.loader,
                          // options: {
                            // ??? не раб - https://webpack.js.org/plugins/mini-css-extract-plugin/#root
                            // `горячий модуль замены` - измен. эл. без перезагрузки страницы
                            // hmr: true,
                            // reloadAll: true
                            // publicPath: "/public/path/to/",
                          // },
                        // },
                        // "css-loader",
                    // ],
                },
              // },
              // CSS + mini + SCSS{
                // $$ npm i -D sass-loader node-sass
                // 2 опции sass(новее++) и node-sass(быстрее++)
                // подкл. .scss в src/.js
                // +++ import './test2.scss';
                {
                  // sass/scss 
                  //test: /\.s[ac]ss$/i,
                  // css, sass, scss
                  test: /\.(sa|sc|c)ss$/,
                  // с fn() cssLoaders без дублей. ЛУЧШЕЕ!!!
                    use: cssLoaders("sass-loader"),
                  // без fn()
                    // use: [
                      // 3. Создает узлы `MiniCss` из строк JS в файлы
                      // {
                        // прямо указ какой loader
                        // loader: MiniCssExtractPlugin.loader,
                      //  options: {},
                      // },
                      // 2. Переводит CSS в обычный JS
                      // "css-loader",
                      // 1. Компилирует Sass в CSS
                      // "sass-loader",
                    // ],
                },
              // }
              // CSS + mini + Less{
                // $$ npm i -D less-loader
                // подкл. .less в src/.js
                // +++ import './test3.less';
                {
                  // только less 
                  test: /\.less$/i,
                  // с fn() cssLoaders без дублей
                    use: cssLoaders("less-loader"),
                  // без fn()
                    // use: [
                      // 3. Создает узлы `MiniCss` из строк JS в файлы
                      // {
                        // прямо указ какой loader
                        // loader: MiniCssExtractPlugin.loader,
                        // options: {},
                      // },
                      // 2. Переводит CSS в обычный JS
                      // "css-loader",
                      // 1. Компилирует Less в CSS
                      // "less-loader",
                    // ],
                },
              // }
              // CSS разраб/прод{
                // !!! https://webpack.js.org/loaders/style-loader/
                // !!! https://webpack.js.org/loaders/sass-loader/
                // test: /\.(sa|sc|c)ss$/,
                // test: /\.s[ac]ss$/i,
                // ||
                // const devMode = process.env.NODE_ENV !== "production";
                // use: [ devMode ? "style-loader" : MiniCssExtractPlugin.loader,
                // "css-loader", "postcss-loader","sass-loader",],
                // plugins: [].concat(devMode ? [] : [new MiniCssExtractPlugin()])
                // ||
                // use: [ // возврат к загрузчику стилей в разработке
                // process.env.NODE_ENV !== "production" ? "style-loader" : MiniCssExtractPlugin.loader,
                // "css-loader", "sass-loader", ],
              // }
            // },
            // Файлы, изо {
              // возм загр. различ файлы (img, xml, )
              // устан loader
              // $$ npm i -D file-loader
              // подкл в js
              // +++ import Logo from './img/logo.png'
              // добав img в js
              // +++ const vrt = new Vrt(logo)||constructor(img){this.img = img;}
              // добав в css 
              // +++ background-image: url("../img/logo.png");
              {
                test: /\.(jpe?g|png|gif|svg)$/i,
                // use: ["file-loader"],
                // use не раб с options
                loader: "file-loader",
                // задаём имя
                // ??? не раб - только имя ../ работает, однако созд папку с файлом за dist
                // такой же файл как из CopyWebPlug., но при уник. имени созд ещё один
                options: {
                  // без ничего только hash.png
                  // name: '[name].[ext]', // файл в dist
                  // name: '../[name].[ext]', // файл за dist
                  name: "img/[name][hash].[ext]", // файл в img/ с hash. созд отдельный файл от копир.
                  // name: '/img/[name].[ext]', // файл в img/
                  // name: './img/[name].[ext]', // файл в img/
                  // name: '../img/[name].[ext]', // парка с файлом за dist
                  // name:`${PATHS.dist}img/[name].[ext]` // не раб - созд. двойной путь до папки от корня
                },
              }
            // },
            // xml {
              // устан. $$, подкл в js, добавл в файл 
              // $$ npm i -D xml-loader
              {
                test: /\.xml$/,
                use: ["xml-loader"],
              }
            // },
            // подкл. csv {
              // устан. $$, подкл в js, добавл в файл
              // $$ npm i -D csv-loader
              // зависит от пакета papaparse который парсит csv в js 
              // $$ npm i -D papaparse
              {
                test: /\.csv$/,
                use: ["csv-loader"],
              }
            // },
          ]
        },
        // расшир/сокращ
        resolve: {
          // расшир. по умолч. чтоб не указыв. в import/export
          extensions: [".js", ".json", ".png"],
          // сокращение/пседвоним указ. на путь
          alias: {
            "@models": path.resolve(__dirname, "src/models"),
            "@": path.resolve(__dirname, "src"),
          },
        },
        // доп настр. знач. можно передать через fn с проверкой на Prod
        optimization: 
          // ч/з fn() возращ. сгенерированый объ. ЛУЧШЕЕ!!!
            optimization: optimization(),
          // объектом
            // {
              // выгружать библ(jQuery, ) в один файл из 2х не связаных файлов
                // splitChunks: {
                // chunks: "all",
              // },
            // }
        // подкл dev-server к webpack для живой перезагрузки
        devServer: {
          // порт для запуска. рекоменд 8081, реже 8080
          port: 8081, // 8080 // 4200,
          // только в разраб
          hot: isDev
        },
        // показ в консоле исходный код файла. для разраб(isDev)
        // ??? не раб - при npm build прибавляет очень много веса объед. файлу js
        // devtool: isDev ? 'source-map' : 'eval',
          // или 
          // devtool: "eval-source-map", 
          // пояснения {
            // eval - мини/строка, source-map - как есть + копия в мини, eval-source-map - рекомендуется
            // после запуска npm run build(start, ) появится app.js.map (мини версия при source-map)
            // source-map технология позволяет посмотреть в браузере какие файлы были подкл. к выходному файлу 
          // }
      };
    ##
  ориг. дог. {
    !!! https://webpack.js.org/configuration/
  }


!!! Прописать как будет всё выгдядить, что ещё создать, структуру, может код
  // пример с док WP
  |- package.json
  |- webpack.config.js
  |- /dist
  |- /src
    |- index.js
  |- print.js
  |- /node_modules

1.6 ++ Создать в корне папку src(любое имя и путь) и файл index.js(любое имя) в ней.


1.7 $$ npm run // dev/build/server - запуск сборки в Dev/Prod/браузер
	++ Появляеться dist/js/app.js. - сбор всего JS кода в один файл
  доп. пояснения
    // Содержимое файла app.js автоматически минимизируется. 
    // Хранит все модули добавл. в сборку(index.js), ч/з importы
    // содерж. каждого файла в отдельной fn() eval. записывается как строка, помещёная в fn() eval
    // eval - нативная fn() в JS которая исполняет код из строки. 
    // eval не рекоменд. использ., только для быстрого исполнения браузер. движ.
    // в шапке технический код webpack для эмуляции модулей внутри браузера
    // модуль - изолир. часть системы со своими перемен., классами, fn(), и т.д.
    // каждый файл - модуль, и никаких конфликтов м/у ними не будет


1.8 ++ Создать в корне файл index.html и подкл. app.js
  код html
    ##
      <!DOCTYPE html>
      <html lang="ru">
      <head>
        <meta charset="UTF-8">
        <title>React</title>
      </head>
      <body>
        <script src="/static/build/app.js"></script>
      </body>
      </html>
    ##
	// теперь webpack-dev-server будет отслеживать любые изменения в файлах и на лету пересобирать приложение



1.7.1 Установил $$ npm i html-webpack-plugin

1.8 Чтобы запускать сборку и сервер было проще, можно прописать соответствующие скрипты в package.json.
	##
	"scripts": {
		"start": "webpack --mode development",
		"server": "webpack-dev-server"
	},
	##
	$$ npm run start
	$$ npm run server
	// Теперь app.js не мини сборка, изза ключа --mode development
1.11 Импорт JS-файлов друг в друга 
	Создадим новый файл: static_src/script.js
	пропишем:
	##
	export function script() {
		console.log('Это файл script.js');
	}
	##
	в static_src/index.js пропишем:
	##
	import { script } from './script';
	script();
	console.log('А это index.js');
	##
	Таким образом, начиная сборку с entry, указанного в webpack.config.js, 
	webpack следует импортам и собирает все файлы в один единственный app.js.


1.13 React.js — это фреймворк для создания интерфейсов. работает по принципу реактивного программирования, 
 	 то есть позволяет создавать динамические страницы с возможностью обновлений состояний
	установка react
	$$ npm install react react-dom
1.13.1  Простейшее приложение на React
	в файле index.js напишем простейший код на React
	##
	import React from 'react';
	import ReactDOM from 'react-dom';
	const element = React.createElement(
		'h1',
		{ className: "element" },
		'Кажется, мы подключили React',
	);

	ReactDOM.render(
		element,
		document.getElementById('root'),
	);
	##
	Здесь создается элемент <h1 class="element">. Кажется, мы подключили React</h1>, 
	который потом вставляется в элемент с id="root". Добавим такой элемент в index.html.
	##
	<div id="root"></div>
	##
	Запускаем
	$$ npm run start
	$$ npm run server
1.14 JSX - синтаксический сахар для функции React.createElement(component, props, ...children). 
	 Это позволяет писать верстку в html-формате внутри JS-файлов.
	заменяем на
	##
	const element = <h1 className="element">Кажется, мы подключили React</h1>;
	##
1.15 Чтоб не получить ошибку: ERROR in ./index.js Module build failed(ошибка сборки модуля)..., 
	 изза того что JavaScript не знает синтаксиса html, установим пресет для React, чтобы с помошью babel смогли переделать JSX во что-то понятное обычному JavaScript.
	$$ npm install @babel/preset-react
	добавить в webpack.config.js
	##
	module: {
			rules: [
				{
						query: {
						presets: ['@babel/env', '@babel/react'],
						}
				},
			],
		},
	}
	##
	так не сработало.
	рабочий
	##
	options: {
          presets: ["@babel/env", "@babel/react"],
      		}
	##
1.16 Тип элемента со строчной буквы - встроенный компонент(<div> или <span>), 
	 передается в виде строки 'div' или 'span' в функцию React.createElement. 
	 Типы с прописной буквы(<Foo />), компилируются как React.createElement(Foo), ссылаются на компонент, 
	 определенный или импортированный в вашем JavaScript-файле. Пример на основе функциональных компонентов.
1.17 Функциональные компоненты позволяют отделить верстку от содержимого. 
	 В отличие от обычных элементов, которые объявляются как переменные, 
	 функциональные компоненты нужно объявлять в виде функций. static_src/index.js:
	##
	const content = 'Кажется, мы всё ещё подключаем React';
	const Component = (props) => <h1 className="element">{props.content}</h1>;
	ReactDOM.render(
		<Component content={ content } />,
		document.getElementById('root_2'),
	);
	##
	Передаём текст в качестве аргумента, что позволит переиспользовать функциональный компонент 
	(определяется с большой буквы). Вызывается с помощью синтаксиса JSX, а переменные, которые передаются в него, 
	попадают в словарь props.
1.18 Реализация, компонентов сообщений в рамках мессенджера.
	static_src/index.js:
	##
	let messages = ['Привет', 'Как дела?'];
	const MessageComponent = (props) => <div>{props.text}</div>;
	const MessageField = (props) => {
		return props.messages.map(message => <MessageComponent text={ message } />);
	};
	ReactDOM.render(
		<MessageField messages={ messages } />,
		document.getElementById('root'),
	);
	##
1.19 Переименуем файл index.js в index.jsx. Впоследствии будем ко всем файлам, использующим синтаксис JSX, 
	 применять это расширение.
1.20 Перед заливкой удалять (?dist?) node_modules(исполнительные файлы тех модулей которые мы устанавливаем).
	возвращаем исполн. файлы после залявки (равнозначно install - i)
	$$  npm i

	в webpack.config.js не помню от куда взялся в output:{ вот это - publicPath: "/static/build/"



	2.Урок........................................................................................


2.1 Чаще всего используют React-компоненты(а не функциональные) на основе классов. 
	Они могут верстать, есть свой жизненный цикл, в который можно «вшивать» собственную логику. 
	State(состояние) — перемен. класса комп-та, влияют на поведение компонента и его отрисовку. 
	Из-pf большого кол-ва компонентов, React передает переменные, от верхнего компон. к нижнему, 
	но не наоборот. React-компоненты со своим жизненным циклом, состоянием (state) и 
	строго иерархическим взаимодействием — это основа фреймворка React. 
2.2 Пишем простейший ReactComponent. В пути будут лежать все наши компоненты.  
	В классе компонента обязательно должна быть реализована функция render(). 
	То, что возвращает эта функция, как раз и выводится на экран.
	Создаём /static_src/components/App.jsx
	##
	import React from 'react' ;
	export default class App extends React. Component {
		render () {
			return (
				<h1> Наш первый React-компонент </h1>
			)
		}
	}
	##
	добавляем его в index.jsx
	##
	import App from './components/App.jsx' ;
		ReactDOM. render (
		<App /> ,
		document.getElementById('root'),
	);	
	##
2.3 Добавим state в компонент App и будем использовать его в рендере компонента: 
	static_src/components/App.jsx, после .... React.Component {
	##
	state = {
		text : 'Наш первый React-компонент'
	} ;
	##
	##
	<h1>{this.state.text}</h1>
	##
2.4 $$ npm install @babel/plugin-proposal-class-propertiesnpm install @babel/plugin-proposal-class-properties
	Ещё один babel, для обработки синтаксиса, пока не доступтного JS
	Пропишем его и в webpack.config.json
	##
	plugins : [
		[
			"@babel/plugin-proposal-class-properties" ,
			{
			"loose" : true
			}
		]
	]
	##
2.5 обновим state через секунду после первой отрисовки компонента. 
	Делается это вызовом функции this.setState()
	В static_src/components/App.jsx в render(){ перед return
	setTimeout(() => this.setState({ 'text': 'Обновленный React-компонент' }), 1000);
2.6 Теперь, при запуске сервера и открытие в браузере приложения, тект, через секунду изменится.
	Обновление state влечет за собой повторный вызов функции render(), и компонент перерисовывается.
	На самом деле вызывается не только функция render() , но об этом позже.
2.7 Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненяного цикла React из функциональных компонентов. 
	Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
	Подоробнее https://ru.reactjs.org/docs/hooks-intro.html
	Функциональные компоненты можно наделить состоянием, с помощью хуков. Жизненный цикл компонента представляет собой вызов ряда методов компонента перед определенными событиями или после них: componentWillMount - функция вызывается перед тем, как компонент будет отрисован, 
	render - ф-я отрисовывает компонент и вызывается при каждом последующем обновлении state,
	componentDidMount - функция вызывается сразу после первой отрисовки компонента на странице,
	componentDidUpdate - функция вызывается при обновлениях после перерисовки
	componentWillUnmoun - функция, которая вызывается при далении компонента со страницы.
	В static_src/components/App.jsx
	##
	componentWillMount() {
		console.log('componentWillMount');
	}
	componentDidMount () {
		console.log('componentDidMount');
		setTimeout(() => this.setState({'text':'Обновленный React-компонент'}),
	1000);
	}
	componentDidUpdate() {
		console.log('componentDidUpdate');
	}
	##
	state переносим из render в componentDidMount
	##  -  Браузер. Консоль разработчика.
	##
	componentWillMount
	render
	componentDidMount
	[WDS] Live Reloading enabled.
	render
	componentDidUpdate
	##
	Второй вызов render и последующий componentDidUpdate были осуществлены после обновления state через секунду после отрисовки компонента.
2.8 Вложенность компонентов, props и propTypes
	Создаём static_src/components/Child.jsx с таким же жизненным циклом.
	##
	import React from 'react' ;
	export default class Child extends React. Component {
		componentWillMount() {
			console.log('Child componentWillMount');
		}
		componentDidMount() {
			console.log('Child componentDidMount');
		}
		componentDidUpdate() {
			console.log('Child componentDidUpdate');
		}
		render() {
			console.log('Child render');
			return(
				<h1>Это компонент Child</h1>
			)
		}
	}
	##
2.9	Вложим Child.jsx в App.jsx. 
	Передадим счетчик в качестве props, добавим кнопку, для увеличения счетчика на единицу.
	В static_src/components/App.jsx
	##
	import Child from './Child.jsx';
	state = {
		text: 'Наш первый React-компонент' ,
		counter: 0,
	};
	.....
	handleClick = () => {
		this.setState ({ 'counter': this.state.counter + 1 })
	};
	render () {
		console.log ('render') ;
		return (
			<div>
				<h1>{this.state.text}</h1>
				<Child counter={this.state.counter}/>
				<button onClick={this.handleClick}>+1</button>
			</div>
		)
	}
	##
	handleClick - стрелочная ф-я, благодаря этому используется контекст компонента App для переменной this внутри нее. Обычная ф-я внутри компонента, «теряется» контекст. Его нужно будет привязать в конструкторе командой this.handleClick.bind(this).
	Компонент Child получает counter в качестве props, который будет увеличиваться на 1 при каждом нажатии на кнопку. Обернули все в <div>, так как render возвращает либо один элемент, либо массив элементов.
2.10 Можно импортировать jsx-файлы без расширения - import Child from './Child'. Добавим в webpack.config.js следующую настройку:
	##
	const webpack = require( 'webpack' ) ;
	module.exports = {
		.....
		resolve: {
			modules: [`${__dirname} /static_src`, 'node_modules'],
			extensions: ['.js', '.jsx'],
		},
	};
	##
2.11 Получим переданный props :
	static_src/components/Child.jsx
	##
	return (
			<h1>Это компонент Child, counter: { this.props.counter}</h1>
		)
	##
2.11.1 Браузер. Консоль разработчика.
	##
	componentWillMount
	render
	Child	componentWillMount
	Child render
	Child componentDidMount
	componentDidMount
	[WDS] Live Reloading enabled
	##
	Внимание на последовательность вызова функций в родительском (App.jsx) и дочернем (Child.jsx) компонентах.
	Нажмём кнопку +1:
	##
	componentWillMount
	render
	Child	componentWillMount
	Child render
	Child componentDidMount
	componentDidMount
	[WDS] Live Reloading enabled
	render
	Child render
	Child componentDidUpdate
	componentDidUpdate
	##
	Внимание на последовательность вызова функций.
	В данном случае дочерний компонент был перерисован, так как перерендерился родительский в результате изменения state.
	Обновление React-компонента происходит не только при обновлении state, но и при изменении props. В целом, набор state и props определяет состояние компонента, изменение которого приводит к его перерисовке. Чтобы принудительно обновить компонент, то можно воспользоваться функцией forceUpdate().
2.12 Для контроля типов передаваемых в компонент propsов можно использовать стороннюю библиотеку PropTypes.
	$$ npm install prop-types
	В static_src/components/Child.JSX
	##
	import PropTypes from 'prop-types';
	export default class Child extends React.Component {
		static propTypes = {
			counter: PropTypes.number ,
		};
	.....
	}	
	##
2.12.1 ???НЕПОНЯТНО???
	если counter окажется строкой, увидим ошибку в панели разработчика
	isRequired означает, что counter обязательно должен быть передан в Child. Если мы забудем передать его, то опять увидим ошибку:
	см. pdf - D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\2. компоненты(Mes,Mese,ChaIn)\Методичка 2.pdf 
	Но если какой-то props не обязательно передавать в компонент, то можно задать значение по умолчанию ( isRequired в таком случае нужно убрать):
	см. pdf - D:\Про\Курсы-ДЗ\Geekbrains\Frond end разраб\React\2. компоненты(Mes,Mese,ChaIn)\Методичка 2.pdf
	static_src/components/Child.jsx
	##
	import React from 'react' ;
	import PropTypes from 'prop-types' ;
	export default class Child extends React. Component {
		static propTypes = {
			counter : PropTypes. number ,
		} ;
		defaultProps = {
			counter : 0 ,
		};
	.....
	}
	##
2.13 Начало разработки мессенджера
	Разработаем интерфейс для мессенджера. Реализация отправки сообщения с одним и тем же текстом по нажатию кнопки.
	Необходим компонент сообщения static_src/components/Message.jsx:
	##
	import React from 'react';
	import PropTypes from 'prop-types';
	export default class Message extends React.Component {
		static propTypes = {
			text: PropTypes.string.isRequired,
		};
		render() {
			return <div> {this.props.text} </div>
		}
	}
	##
2.13.1 Компонент с кнопкой отправки сообщения, и сообщениями в качестве дочерних компонентов.
	В методичке забыли вписать sender={message.sender}
	static_src/components/MessageField.jsx
	##
	import React from 'react' ;
	import Message from './Message' ;
	export default class MessageField extends React. Component {
		state = {
			messages : [ "Привет!", "Как дела?" ]
		} ;
		handleClick = () => {
			this.setState ({ messages: [... this.state.messages, 'Нормально' ] }) ;
		} ;
		render() {
			const messageElements = this.state.messages.map ((text, index) => (
				<Message text = { text } sender={message.sender} key = {index} /> )) ;
		return <div>
			{messageElements}
			<button onClick={this.handleClick}>Отправить сообщение</button>
			</div>
		}
	}
	##
2.13.2 В state MessageField храним тексты сообщений в массиве. 
	При отрисовке в функции render получаем по этому массиву строк массив компонентов Message, который и отрисовываем внутри MessageField. А при нажатии кнопки «Отправить сообщение» мы просто добавляем новое сообщение справа к текущему массиву в state .
2.13.3 Заменяем импорт App на импорт MessageField в index.jsx.
	static_src/components/index.jsx
	##
	import App from './components/App' 
	---> 
	import App from './components/MessageField';
	##
	##
	Привет!
	Как дела?
	Нормально
	Нормально
	##
	"Нормально" выводиться после нажатия на кнопку "Отправить сообщение"
2.14 Реализация ответа от робота.
	Оживим мессенджер — реализуем ответ от робота на каждое наше сообщение с небольшой задержкой. Для этого будем использовать функцию componentDidUpdate. Но при реализации «в лоб» получится зацикливание:
	static_src/components/MessageField.jsx
	##
	import React from 'react' ;
	import Message from './Message' ;
	export default class MessageField extends React. Component {
		.....
		componentDidUpdate () {
			setTimeout (() =>
			this . setState (
				{ messages : [... this . state . messages , 'Не приставай ко мне, я робот!'
			] }) , 1000 ) ;
		}
		.....
	}
	##
	##
	Привет!
	Как дела?
	Нормально
	Не приставай ко мне, я робот!
	Не приставай ко мне, я робот!
	Не приставай ко мне, я робот!
	Не приставай ко мне, я робот!
	Не приставай ко мне, я робот!
	##
	Ответ на каждое смс с задердкой в 1 секунду
2.14.1 Происходит ответ на каждое сообщение. Чтобы этого избежать, нужно различать сообщения пользователя и робота. Самым быстрым, но не очень надежным решением будет ответ только на нечетные сообщения.
	static_src/components/MessageField.jsx
	##
	componentDidUpdate() {
		// 14.1
		if (this.state.messages.length % 2 === 1) { // Остаток от деления на 2
			// 14.
			setTimeout(() =>
				this.setState(
					{ messages: [... this.state.messages, 'Не приставай ко мне, я робот!'] }),
				1000);
		}
	}	
	##
	##
	Привет!
	Как дела?
	Нормально
	Не приставай ко мне, я робот!
	Нормально
	Не приставай ко мне, я робот!
	##
	Ответ на каждое 2ое смс(?т.е. 1 нажатие + ответ = 2 смс?) с задердкой в 1 секунду.
!!! Итоги
	1. Каждый компонент в React имеет состояние (переменная state) и жизненный цикл, заключающийся в вызове определенного набора функций.
	2. Изменение state путем вызова функции setState() влечет за собой перерисовку компонента и вызов функции componentDidUpdate .
	3. Компоненты могут быть вложены друг в друга и так образовывать иерархию. В ней родительские компоненты могут передавать дочерним переменные (props), но не наоборот.



	3.Урок.......................................................................................


3.0 Что такое Virtual DOM
	DOM (Document Object Model) — способ представления структурного документа с помощью объектов.Это кроссплатформенное и языконезависимое соглашение для представления данных в HTML, XML (и др.) и взаимодействия с ними. Веб-браузеры обрабатывают составляющие DOM и позволяют взаимодействовать с ними, используя JavaScript и CSS.
	Основная проблема в использовании DOM — то, что он не предусмотрен для разработки динамических пользовательских интерфейсов, поэтому появляются проблемы с производительностью.
	Есть несколько вариантов их решить. Один из них — стандарт Shadow DOM. Эта спецификация описывает метод объединения нескольких DOM-деревьев в одну иерархию и то, как эти деревья взаимодействуют в пределах документа. Это позволяет лучше скомпоновать DOM.
	Другой вариант — Virtual DOM. Эта модель предлагает использовать вместо реального DOM-дерева его легковесные копии. В этом случае при отрисовке приложения происходит не взаимодействие напрямую с DOM, а редактирование его копий, а после, при необходимости, внесение изменений в реальное DOM-дерево.
	DOM-дерево сравнивается с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.
	Преимущества такого метода:
	● увеличивается скорость реакции на изменение компонента (поскольку виртуальная копия не содержит частей реального DOM-дерева);
	● выполняется отрисовка только того компонента, который необходимо изменить, а не всего DOM-дерева;
	● метод выполняется посредством библиотеки React.
	Virtual DOM — это техника и набор библиотек / алгоритмов, которые позволяют улучшить производительность на клиентской стороне. Мы избегаем прямой работы с DOM, взаимодействуя с JavaScript-объектами, имитирующими DOM-дерево. И это одна из основных вещей под капотом React, обеспечивающих его высокую производительность.
3.1 Хранение автора сообщения. Для реализации начнём хранить в массиве messages, словари вместо строк. Теперь возможно реализовать ответ от робота не по косвенному признаку четности/нечетности сообщений, а по автору.
	static_src/components/MessageField.jsx
	##
	state = {
		messages: [
			{ text: "Привет!", sender: 'bot' },
			{ text: "Как дела?", sender: 'bot' }
		],
	};
	componentDidUpdate() {
		if (this.state.messages[this.state.messages.length - 1].sender === 'me') {
			setTimeout(() =>
				this.setState({
					messages: [... this.state.messages,
					{ text: 'Не приставай ко мне, я робот!', sender: 'bot' }]
				}), 1000);
		}
	}
	handleClick = () => {
		this.setState({
			messages: [... this.state.messages,
			{ text: 'Нормально', sender: 'me' }]
		});
	};
	render() {
		const messageElements = this.state.messages.map((message, index) => (
			<Message text={message.text} sender={message.sender} key={index} />));
		return <div>
			{messageElements}
			<button onClick={this.handleClick}>Отправить сообщение</button>
		</div>
	}
	##
3.2 Стилизация React-компонентов. В React стилизация происходит так же, как в обычном HTML: либо при помощи классов/id, либо inline. Опробуем оба метода, чтобы визуально отличить наши сообщения от отправленных роботом.
3.2.1 Свойством className задается класс элемента, id используется чтобы задать id. Обратите внимание, что в React нужно применять именно className , атрибут class работать не будет
	static_src/components/MessageField.jsx
	##
	return <div id='main' className='message-field' >
			{messageElements}
			<button onClick={this.handleClick}>Отправить сообщение</button>
		</div>
	##
	##
	<div id="main" class="message-field">
		<div>Привет!</div>
		<div>Как дела?</div>
		<div>Отправить сообщение</div>
	</div>
	##
3.3 Подключаем файлы css, чтобы применились стили. Простой способ - в index.html. Удобный способ, от webpack - включить css-файлы прямо в сборку.
	Тогда браузер пользователя будет подгружать стили вместе со всем приложением и ему не придется тратить время на отдельные запросы.
	В описанном случае подключение происходит при помощи import:
	Создадим css-файл в отдельной папке styles.
	static_src/styles/styles.css
	##
	.message-field {
		background-color: lightblue;
	}
	##
	И подключим его в MessageField.jsx:
	static_src/components/MessageField.jsx
	##
	import '../styles/styles.css';
	##
3.3.1 Чтоб не получить ошибку призапуске, подключим CSS loader’ы, которые позволят обрабатывать CSS-файлы при сборке.
	$$ npm install css-loader style-loader
	Добавим в webpack.config.js
	##
	rules: [
		.....
		{
			test : /\.css$/,
			loader : 'style-loader!css-loader',
		},
	]
	##
	@@  -  внешний вид
	@@
	Теперь есть заливка смс цветом. Причем её можно отследить по структуре документа в панели разработчика. Стили подключены при помощи тега <style> в шапке документа.
	@@
	##
	<head>
		.....
		<style>
			.message-field {
			.....
			}
		</style>
	</head>
	##
3.4 Inline style(`встроенный стиль`). Этого же можно добится передав встроенным компонентам (<div>, <span> и т. д.) объект со стилями в качестве параметра style:
	static_src/components/MessageField.jsx
	##
	return <div style = { { backgroundColor: 'lightblue' } } >
	##
	В этом случае все делается так же, как в HTML, только все дефисы в названиях свойств (kebab-case) исправляются на camelCase ( background-color —backgroundColor). Значения свойств должны быть либо числами, либо строками.
3.5 Стилизуем сообщения. Комбинируя эти два подхода, стилизуем сообщения так, чтобы было отчетливо видно, какое из них принадлежит пользователю, а какое — роботу.
	static_src/styles/styles.css
	##
	.message-field {
		display: flex;
		flex-direction: column;
		background-color: #e2e2e2;
		height: 50%;
		width: 100%;
		padding: 20px;
		overflow-y: scroll;
	}
	.layout {
		height: 100%;
		width: 50%;
		margin: auto;
		display: flex;
		align-items: center;
		justify-content: center;
		flex-direction: column;
	}
	.message {
		background-color: lightblue;
		padding: 5px 15px;
		border-radius: 20px;
		font-size: 18px;
		margin: 5px;
	}
	.message-sender {
		color: gray;
		font-size: 14px;
	}
	##
3.5.1	В static_src/components/MessageField.jsx
	##
	return <div className ="layout" >
		<div className ="message-field" >
			{ messageElements }
		</div>
	##
3.5.2	В static_src/components/Message.jsx
	##
	static propTypes = {
		text: PropTypes.string.isRequired,
		sender: PropTypes.string.isRequired,
	};
	return <div
			className="message"
			style={{ alignSelf: this.props.sender === 'bot' ? 'flex-start' : 'flex-end' }}
		>
			<div>{this.props.text}</div>
			<div className="message-sender">{this.props.sender}</div>
		</div>
	##
3.5.2	В index.html
	##
	<body style="height: 100%; margin: 0">
	<div style="height: 100%" id="root"></div>
	##
	@@
	Привет!
	bot
												Ку!
												me
	Как дела
	bot
				Отправить сообщение
	@@
	???НЕ совсем понятно выпадение страницы в ноль при отключение root_ на горячую. При откл. из index.jsx норм. А при откл из index.html после обновления пропадает всё???
3.6 Обработка событий. Для возможности писать разные сообщения, а не отправлять одно и то же. Для этого в React есть события и их обработчики.
	React стандартизирует все браузерные события при помощи SyntheticEvent, что позволяет событиям работать одинаково во всех браузерах. Для обработки событий нужно передать атрибут в JSX-тег в camelCase-стиле по шаблону: onИмяСобытия (например, onClick), — и передать в него функцию-обработчик.
	Важно! Обработчики событий работают только для базовых компонентов React(div, button и т.д.).Для созданных нами компонентов они работать не будут.
3.6.1 onClick(`по щелчку`). Этот обработчик мы уже используем для отправки сообщений
	##
	<button onClick = {this.handleClick} >Отправить сообщение</button>
	.....
	handleClick = () => {
		this.setState ({ messages: [... this.state.messages, {text: 'Нормально', sender: 'me'}]});
	};
	##
	Чтобы передавать сообщение в качестве аргумента функции handleClick, то нужно будет сделать промежуточную стрелочную функцию. Иначе handleClick вызовется, не дожидаясь самого клика.
	##
	<button onClick={() => this.handleClick('Нормально')}>Отправить сообщение</button>
	.....
	handleClick = (message) => {
		this.setState({
			messages: [... this.state.messages, { text: message, sender: 'me' }]
		});
	};
	##
3.6.2 onChange(`по изменению`). Для ввода сообщения необходимо текстовое поле. Любое изменение в текстовом поле, будь то написание нового символа или удаление уже написанного, генерирует событие, которое можно обработать при помощи onChange:
	##
	<input onChange = {this.handleChange} />
	.....
	handleChange = (event) => {
		console.log(event.target.value);
	};
	##
	???Пока ничего не записывал в код и не выводил???
	Обратите внимание, что аргумент event по умолчанию попадает в функцию. В результате можно
	увидеть следующее:
	##
	н
	но
	нор
	норм
	норма
	.....
	##
3.6.3 onKeyUp(`на клавиатуре`). Чтобы отправлять сообщения с клавиатуры (Enter), с помощью обработчика onKeyUp, который будет вызываться при поднятии кнопки после нажатия на нее.
	##
	<input onChange = {this.handleChange} onKeyUp = {(event) => this.handleKeyUp(event,'Нормально')} />
	.....
	handleKeyUp = (event, message) => {
		if (event.keyCode === 13) { // Enter
			this.setState({
				messages: [... this.state.messages, {text: message, sender: 'me'}]
			});
		}
	};
	##
	Внимание на следующие моменты
	1. event.keyCode позволяет получить уникальный код клавиши на клавиатуре, которую нажал пользователь. Узнать код любой клавиши можно https://keycode.info/
	2. Так как обработчик onKeyUp «висит» на <input>, то обрабатываться нажатия кнопок будут только при фокусе на этом input’е.
	3. Обрабатываться будут нажатия всех кнопок, а отсев нужной уже проводится внутри handleKeyUp.
	Теперь можно отправлять сообщения Enter’ом. Правда, по-прежнему отправляется одно и то же сообщение, а не то, что мы ввели. Исправим это.
3.4 Написание и отправка сообщения в мессенджере — реализация.
	Реализуем такую функциональность:
	1. Добавим state-переменную input и будем сохранять в нее текст, введенный пользователем, используя обработчик события onChange.
	2. Переменную input будем передавать в качестве аргумента в handler’ы для onClick и onKeyUp.
	static_src/components/MessageField.jsx
	##
	state = {
		.....
		input: '',
	};
	.....
	handleClick = (message) => {
		this.sendMessage(message)
	};
	handleChange = (event) => {
		this.setState({input: event.target.value});
	};
	handleKeyUp = (event, message) => {
		if (event.keyCode === 13) { // Enter
			this.sendMessage(message)
		}
	};
	sendMessage = (message) => {
		this.setState({
			messages: [... this.state.messages, {text: message, sender: 'me'}]
		});
	};
	.....
	##
	@@
	Привет!
	bot
												Ку!
												me
	Как дела
	bot
												текст
												me
	Не приставай ко мне, я робот!
	bot
				тект
				Отправить сообщение
	@@
3.5 Хотелось бы еще очищать поле ввода после отправки сообщения. Для этого нужно не только читать то, что пользователь пишет в <input> при помощи onChange, но и самим контролировать, что там написано. А для этого — передавать переменную input из state в качестве параметра value и очищать эту переменную при отправке сообщения:
	static_src/components/MessageField.jsx
	##
	sendMessage = (message) => {
		.....
		input : '' ,
		}) ;
	} ;
	.....
	value={this.state.input}
	##
3.5.1 Если в вашем интерфейсе будет несколько полей ввода (например, в форме регистрации), их можно обрабатывать одной и той же функцией. Для этого используют параметр name, который в JavaScript попадает в event. Нужно, чтобы переменная из state совпадала с name связанного с этой переменной input’а. Тогда можно применять name в качестве ключа в setState:
	##
	handleChange = (event) => {
		this.setState({ [event.target.name]: event.target.value });
	.....
	<input
		name ="input"
	##
3.6 Неуправляемые компоненты. Наша реализация обработки событий основана на управляемых компонентах, то есть данные формы обрабатываются React-компонентом. В большинстве случаев при работе с формами используют
именно их.
	В качестве альтернативы можно использовать неуправляемые компоненты. Они хранят данные формы прямо в DOM. Вместо того чтобы писать обработчик события для каждого обновления состояния, можно использовать неуправляемый компонент и читать значения из DOM через ref.
	Рассмотрим работу ref’ов на примере реализации автофокуса на поле ввода. То есть при открытии приложения пользователь сразу же сможет начать вводить сообщение, не кликая предварительно мышью по полю.
	Ref’ы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref-атрибут.
	теория
	##
	class MyComponent extends React.Component {
		constructor(props) {
			super(props);
			this.myRef = React.createRef();
		}
		render() {
			return <div ref={this.myRef} />;
		}
	}
	##
	Когда ref передается элементу в методе render, ссылка на данный узел становится доступна через свойство ref’а current.
	##
	const node = this .myRef. current ;
	##
3.6.1 Используя эту информацию, реализуем автофокус.
	static_src/components/MessageField.jsx
	##
	constructor(props) {
		super(props);
		// создадим ref в поле `textInput` для хранения DOM-элемента
		this.textInput = React.createRef();
	}
	.....
	// Ставим фокус на <input> при монтировании компонента
	componentDidMount() {
		this.textInput.current.focus();
	}
	.....
	ref={this.textInput}
	##
3.7 ???Не работает???
	Подключение и использование Material-UI. Чтобы не верстать все компоненты с нуля, можно использовать библиотеки готовых компонентов. Существует несколько популярных UI-библиотек от разных компаний.
	Material UI(https://material-ui.com/ru/) — библиотека от Google, которая позволяет создавать приложения в стиле Google Material Design с использованием компонентов React.
	Ant Design(https://ant.design/docs/react/introduce) — это библиотека от Alibaba, основанная на React. Она разработана в Китае, но качественно переведена на английский, так что доступ к ней есть и у англоговорящих разработчиков.
	React Bootstrap(https://react-bootstrap.github.io/) — библиотека от Twitter. В целом, семейство bootstrap является самым популярным фронтенд-фреймворком.
	Grommet(https://v2.grommet.io/) — библиотека от HP. Она отличается красивыми визуализациями.
	Рассмотрим Material-UI — она проста в подключении и использовании.
3.7.1 Установим Material-UI:
	$$ npm install material-ui
	Чтобы библиотека заработала, нужно в самом верху нашего приложения разместить <MuiThemeProvider>
	Добавим в static_src/index.jsx
	##
	import MuiThemeProvider from 'material-ui/styles/MuiThemeProvider' ;
	ReactDOM.render (
		<MuiThemeProvider>
			<MessageField />
		</MuiThemeProvider>,
		document.getElementById ('root'),
	);
	##
	Это необходимо, чтобы библиотека Material могла контролировать тему всех своих компонентов. Под капотом это делается пробрасыванием props вниз. Именно поэтому компонент провайдера темы должен быть расположен вверху. Как это устроено, мы увидим в следующих уроках, когда будем работать с Redux.
	Полный список компонентов можно посмотреть https://v0.material-ui.com/#/components/app-bar. 
3.7.2 Мы будем использовать TextField, FloatingActionButton и иконку для верстки поля ввода и кнопки отправки:
	Добавим в static_src/components/MessageField.jsx
	##
	import { TextField, FloatingActionButton } from 'material-ui';
	import SendIcon from 'material-ui/svg-icons/content/send';
	.....
	<div style={{ width: '100%', display: 'flex' }} >
		<TextField
			name="input"
			fullWidth={true}
			hintText="Введите сообщение"
			style={{ fontSize: '22px' }}
			onChange={this.handleChange}
			value={this.state.input}
			onKeyUp={(event) => this.handleKeyUp(event,
				this.state.input)}
		/>
		<FloatingActionButton onClick={() =>
			this.handleClick(this.state.input)} >
			<SendIcon />
		</FloatingActionButton>
	</div>
	##
	Обратите внимание, что кастомизация компонентов происходит путем передачи в них props’ов (fullWidth, hintText в примере выше). Полный список props для каждого компонента можно посмотреть в https://v0.material-ui.com/#/components/app-bar
	В результате
	@@

	@@
	???С 3.7 ВСЁ СЛОМАЛОСЬ???